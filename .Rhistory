repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
setwd("~/Downloads/workspace")
# Hazard variables
he <- seq(0, 5, 0.01)  # water depth (m)
velocity <- 0.1  # velocity (m/s)
sediment_concentration <- 0.05  # sediment concentration (-)
duration <- 24    # flood duration (h)
water_quality <- 1     # water quality (presence of pollutants) 1=yes 0=no
# Example script to run INSYDE using the default settings
#install.packages("truncnorm")
library(truncnorm)
# Change working directory if necessary
# setwd(".")
# Load INSYDE main function
source("insyde_function.R")
# Read hazard and exposure variables
source("hazard_variables.R")
source("exposure_variables.R")
# Read unit prices
up <- read.table("unit_prices.txt")
# Read replacement values
repValData <- read.table("replacement_values.txt", header = TRUE)
repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
getwd()
# Example script to run INSYDE using the default settings
#install.packages("truncnorm")
library(truncnorm)
# Change working directory if necessary
# setwd(".")
# Load INSYDE main function
source("insyde_function.R")
# Read hazard and exposure variables
source("hazard_variables.R")
source("exposure_variables.R")
he <- seq(0, 5, 0.01)  # water depth (m)
velocity <- 0.2  # velocity (m/s)
sediment_concentration <- 0.05  # sediment concentration (-)
duration <- 24    # flood duration (h)
water_quality <- 1     # water quality (presence of pollutants) 1=yes 0=no
# Read unit prices
up <- read.table("unit_prices.txt")
# Read replacement values
repValData <- read.table("replacement_values.txt", header = TRUE)
repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
# Example script to run INSYDE using the default settings
#install.packages("truncnorm")
library(truncnorm)
# Change working directory if necessary
# setwd(".")
# Load INSYDE main function
source("insyde_function.R")
# Read hazard and exposure variables
source("hazard_variables.R")
source("exposure_variables.R")
he <- seq(0, 5, 0.01)  # water depth (m)
velocity <- 1  # velocity (m/s)
sediment_concentration <- 0.05  # sediment concentration (-)
duration <- 24    # flood duration (h)
water_quality <- 1     # water quality (presence of pollutants) 1=yes 0=no
# Read unit prices
up <- read.table("unit_prices.txt")
# Read replacement values
repValData <- read.table("replacement_values.txt", header = TRUE)
repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
# Example script to run INSYDE using the default settings
#install.packages("truncnorm")
library(truncnorm)
# Change working directory if necessary
# setwd(".")
# Load INSYDE main function
source("insyde_function.R")
# Read hazard and exposure variables
source("hazard_variables.R")
source("exposure_variables.R")
he <- seq(0, 5, 0.01)  # water depth (m)
velocity <- 0.9  # velocity (m/s)
sediment_concentration <- 0.05  # sediment concentration (-)
duration <- 24    # flood duration (h)
water_quality <- 1     # water quality (presence of pollutants) 1=yes 0=no
# Read unit prices
up <- read.table("unit_prices.txt")
# Read replacement values
repValData <- read.table("replacement_values.txt", header = TRUE)
repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
# Example script to run INSYDE using the default settings
#install.packages("truncnorm")
library(truncnorm)
# Change working directory if necessary
# setwd(".")
# Load INSYDE main function
source("insyde_function.R")
# Read hazard and exposure variables
source("hazard_variables.R")
source("exposure_variables.R")
he <- seq(0, 5, 0.01)  # water depth (m)
velocity <- 0.1  # velocity (m/s)
sediment_concentration <- 0.05  # sediment concentration (-)
duration <- 24    # flood duration (h)
water_quality <- 1     # water quality (presence of pollutants) 1=yes 0=no
# Read unit prices
up <- read.table("unit_prices.txt")
# Read replacement values
repValData <- read.table("replacement_values.txt", header = TRUE)
repVal <- repValData[BS, BT]
# Define whether or not to consider uncertainty
uncert <- 0
if (!uncert) {
# Compute expected damage. Note that (only) one of the hazard variables can
# be passed to the function as a vector.
modelOutput <- ComputeDamage(he, velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert)
} else if (uncert) {
# Probabilistic computation. All the hazard variables must be passed to the
# function as scalars.
# This example assumes that the variable he is a vector. It is therefore
# necessary to iterate over its elements and pass them to the function one
# at a time.
nrSim <- 2000
statMat <- matrix(NA, nrow = length(he), ncol = 4)
for (i in 1:length(he)) {
modelOutput <- ComputeDamage(he[i], velocity, duration, sediment_concentration, water_quality,
FA, IA, BA, EP, IH, BH, GL, NF, BT, BS, PD, PT, FL, YY, LM,
repVal, up, uncert, nrSim)
# For each element of he, calculate some summary statistics and save them
# to a matrix.
statMat[i, 1] <- quantile(modelOutput$absDamage, .05)
statMat[i, 2] <- mean(modelOutput$absDamage)
statMat[i, 3] <- quantile(modelOutput$absDamage, .95)
statMat[i, 4] <- mean(modelOutput$relDamage)
}
}
par(mar = c(5, 4.2, 4, 4.5))
plot(he, modelOutput$absDamage, type = "l", lwd = 2, ylim = c(0, max(modelOutput$absDamage) * 1.12), xlab = "Water depth (m)", ylab = "Damage (€)", main = "Building damage", panel.first = grid(NULL))
lines(he, modelOutput$groupDamage[, "dmgCleanUp"], lwd = 2, col = "green4")
lines(he, modelOutput$groupDamage[, "dmgRemoval"], lwd = 2, col = "blue4")
lines(he, modelOutput$groupDamage[, "dmgNonStructural"], lwd = 2, col = "darkorange")
lines(he, modelOutput$groupDamage[, "dmgStructural"], lwd = 2, col = "firebrick1")
lines(he, modelOutput$groupDamage[, "dmgFinishing"], lwd = 2, col = "gold2")
lines(he, modelOutput$groupDamage[, "dmgSystems"], lwd = 2, col = "green1")
par(new = TRUE)
plot(he, modelOutput$relDamage, type = "l", lwd = 2, axes = FALSE, ylim = c(0, max(modelOutput$relDamage) * 1.12), xlab = NA, ylab = NA)
axis(side = 4)
mtext(side = 4, line = 3, "Relative damage")
legend("topleft", bg = "white", c("damage total","cleanup","removal","non structural","structural","finishing+WD","systems"), fill = c("black","green4","blue4","darkorange","firebrick1","gold2","green1"))
install.packages("PerformanceAnalytics")
?install.packages
knitr::opts_chunk$set(echo = F)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE, repos = "https://cloud.r-project.org")
sapply(pkg, require, character.only = TRUE)
}
package = c("ropenaq", "knitr", "xts", "PerformanceAnalytics")
ipak(package)
countries_table <- aq_countries()
kable(countries_table)
cities_tableIndia <- aq_cities(country="NL", page = 1)
kable(cities_tableIndia)
locations_chennai <- aq_locations(country = "NL", city = "Utrecht", parameter = "no2")
kable(locations_chennai)
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2" , limit = 20, date_from="2020-07-20", page = 1)
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2"  , date_from="2020-05-01", page = 1)
?aq_measurements
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2"  ,   page = 1)
results_table <- aq_measurements(country = "NL", city = "utrecht", parameter = "no2"  , date_from="2020-05-01", page = 1)
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2"  , date_from="2020-05-01", page = 1)
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2"  , date_from="2020-05-01", page = 1)
output <- aq_measurements(country='IN', limit=9, city='Chennai',
page = 1)
version("ropenaq")
sessionInfo()
results_table <- aq_measurements(country = "NL", city = "Utrecht", parameter = "no2"  , date_from="2020-05-01", page = 1)
load("~/Downloads/global_annual.Rda")
library(devtools)
use_data(global_annual)
use_data(global_annual, overwrite = T)
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path = 'Figs_geohub/',
echo=T, include = T, warning = FALSE, message = FALSE)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
#repos='http://cran.muenster.r-project.org'
stdata = c("sp", "sf", "raster")
Stat_methods = c("lme4", "glmnet", "ranger", "gbm", "xgboost", "party", "caret", "gstat")
visual = c("RColorBrewer", "ggplot2", "corrplot", "tmap" )
map = c("maptools")
tidy = c("devtools", "dplyr",  "tidyr",  "knitr")
other = c("countrycode", "data.table", "Matrix", "GGally", "pdp")
optional = c("leafem",   "vip", "DT", "sparkline","leaflet", "mapview", "htmlwidgets", "rasterVis", "tibble", "shiny") # for the chuncks to be run after work shop or other experienments (other scripts but in this workshop).
packages <- c(stdata, tidy, Stat_methods, visual, map, other)
ipak(packages)
install_github("mengluchu/APMtools")
library(APMtools)
ls("package:APMtools")
#gd = fread("~/Documents/GitHub/Global mapping/2020_06_world/stations_20200602.csv")
#avg = fread("~/Documents/GitHub/Global mapping/oaqEUAUCAUS.csv")
#gdata = merge(gd, avg, by.x = c("long", "lat"), by.y = c("LONGITUDE","LATITUDE" ))
#g1 = na_if(gdata, -9999.9)
#g2 = g1%>%dplyr::select(-id, -dir, -V1)%>%filter(value_mean >0)
data("global_annual")
global_annual %>% dplyr::select(value_mean ) %>% summary()
#datatable(g2, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX = T))
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
summary(global_annual)
summary(global_annual$value_mean)
load("~/Downloads/global_annual.Rda")
summary(global_annual$value_mean)
use_data(global_annual, overwrite = T)
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path = 'Figs_geohub/',
echo=T, include = T, warning = FALSE, message = FALSE)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
#repos='http://cran.muenster.r-project.org'
stdata = c("sp", "sf", "raster")
Stat_methods = c("lme4", "glmnet", "ranger", "gbm", "xgboost", "party", "caret", "gstat")
visual = c("RColorBrewer", "ggplot2", "corrplot", "tmap" )
map = c("maptools")
tidy = c("devtools", "dplyr",  "tidyr",  "knitr")
other = c("countrycode", "data.table", "Matrix", "GGally", "pdp")
optional = c("leafem",   "vip", "DT", "sparkline","leaflet", "mapview", "htmlwidgets", "rasterVis", "tibble", "shiny") # for the chuncks to be run after work shop or other experienments (other scripts but in this workshop).
packages <- c(stdata, tidy, Stat_methods, visual, map, other)
ipak(packages)
install_github("mengluchu/APMtools")
library(APMtools)
ls("package:APMtools")
#gd = fread("~/Documents/GitHub/Global mapping/2020_06_world/stations_20200602.csv")
#avg = fread("~/Documents/GitHub/Global mapping/oaqEUAUCAUS.csv")
#gdata = merge(gd, avg, by.x = c("long", "lat"), by.y = c("LONGITUDE","LATITUDE" ))
#g1 = na_if(gdata, -9999.9)
#g2 = g1%>%dplyr::select(-id, -dir, -V1)%>%filter(value_mean >0)
data("global_annual")
vastring = "road|nightlight|population|temp|wind|trop|indu|elev"
global_annual %>% dplyr::select(value_mean ) %>% summary()
#datatable(g2, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX = T))
install_github("mengluchu/APMtools")
library(APMtools)
ls("package:APMtools")
install_github("mengluchu/APMtools", force = T)
library(APMtools)
ls("package:APMtools")
#gd = fread("~/Documents/GitHub/Global mapping/2020_06_world/stations_20200602.csv")
#avg = fread("~/Documents/GitHub/Global mapping/oaqEUAUCAUS.csv")
#gdata = merge(gd, avg, by.x = c("long", "lat"), by.y = c("LONGITUDE","LATITUDE" ))
#g1 = na_if(gdata, -9999.9)
#g2 = g1%>%dplyr::select(-id, -dir, -V1)%>%filter(value_mean >0)
data("global_annual")
global_annual %>% dplyr::select(value_mean ) %>% summary()
#datatable(g2, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX = T))
load("~/Downloads/global_annual.rda")
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
summary(global_annual$value_mean)
load("~/Downloads/global_annual.rda")
summary(global_annual$value_mean)
use_data(global_annual, overwrite = T)
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
use_data(global_annual, overwrite = T)
load("~/Downloads/global_annual.rda")
use_data(global_annual, overwrite = T)
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path = 'Figs_geohub/',
echo=T, include = T, warning = FALSE, message = FALSE)
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
#repos='http://cran.muenster.r-project.org'
stdata = c("sp", "sf", "raster")
Stat_methods = c("lme4", "glmnet", "ranger", "gbm", "xgboost", "party", "caret", "gstat")
visual = c("RColorBrewer", "ggplot2", "corrplot", "tmap" )
map = c("maptools")
tidy = c("devtools", "dplyr",  "tidyr",  "knitr")
other = c("countrycode", "data.table", "Matrix", "GGally", "pdp")
optional = c("leafem",   "vip", "DT", "sparkline","leaflet", "mapview", "htmlwidgets", "rasterVis", "tibble", "shiny") # for the chuncks to be run after work shop or other experienments (other scripts but in this workshop).
packages <- c(stdata, tidy, Stat_methods, visual, map, other)
ipak(packages)
install_github("mengluchu/APMtools")
library(APMtools)
ls("package:APMtools")
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
summary(global_annual$value_mean)
library(devtools)
use_data(global_annual, overwrite = T)
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
summary(global_annual$value_mean)
library(devtools)
use_data(global_annual, overwrite = T)
load("~/Documents/GitHub/Global mapping/station_predictor/global_annual.rda")
summary(global_annual$value_mean)
library(devtools)
use_data(global_annual, overwrite = T)
xgb_stack
library(APMtools)
xgb_stack
library(xgboost)
?xgboost
100000/60
100000/60/24
